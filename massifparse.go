/*
Package massifparse implements a basic (likely incomplete parser) for heap
profiles generated by the `massif` tool. Massif is part of the Valgrind suite
of tools, more information can be found at:
https://valgrind.org/docs/manual/ms-manual.html
*/
package massifparse

import (
	"bufio"
	"fmt"
	"io"
	"strconv"
	"strings"
	"text/template"

	"github.com/martinlindhe/unit"
)

const (
	snapshotSeparator = "#-----------"
)

// Snapshot is the type of a "heap snapshot". Massif files are basically a
// sequence of these taken over the life of the program being analyzed.
type Snapshot struct {
	// Index is index of this snapshot in the Massif output file.
	Index int
	// Time is the raw repesentation of the time this snapshot was taken saved
	// in the Massif output file. The units of this file depend on
	// `Massif.TimeUnit`.
	Time            string
	MemoryHeap      unit.Datasize
	MemoryHeapExtra unit.Datasize
	MemoryStack     unit.Datasize
	// HeapTree is the raw representation of the "heap tree" included in the
	// output file.
	HeapTree string
}

// Massif represents a parsed Massif output file. The fields in this struct
// correspond to the fileds in the Massif file "header". `Binary` is the
// command that was run under massif, and `Args` are any flags that were
// provided to the binary during analysis.
type Massif struct {
	Description string
	Binary      string
	Args        []string
	TimeUnit    string
	Snapshots   []Snapshot
}

var snapshotTemplate = template.Must(template.New("snapshot").
	Funcs(map[string]interface{}{
		"floatToInt": func(f float64) int64 { return int64(f) },
	}).
	Parse(
		strings.Join([]string{
			snapshotSeparator,
			`snapshot={{ .Index }}`,
			snapshotSeparator,
			`time={{ .Time }}`,
			`mem_heap_B={{ .MemoryHeap.Bytes | floatToInt }}`,
			`mem_heap_extra_B={{ .MemoryHeapExtra.Bytes | floatToInt }}`,
			`mem_stacks_B={{ .MemoryStack.Bytes | floatToInt }}`,
			`heap_tree={{ if eq .HeapTree "" }}empty{{ else }}detailed`,
			`{{ .HeapTree }}{{ end }}`,
			``,
		}, "\n"),
	),
)

// Serialze writes this parsed massif file into the given writer in the massif
// file format. The written content should the be the same as the original file,
// modulo a trailing newline.
func (m *Massif) Serialize(out io.Writer) error {
	if m.Description != "" {
		if _, err := fmt.Fprintln(out, "desc:", m.Description); err != nil {
			return err
		}
	}
	if m.Binary != "" {
		var cmd strings.Builder
		cmd.WriteString(m.Binary)
		for _, arg := range m.Args {
			cmd.WriteByte(' ')
			cmd.WriteString(arg)
		}
		if _, err := fmt.Fprintln(out, "cmd:", cmd.String()); err != nil {
			return err
		}
	}
	if m.TimeUnit != "" {
		if _, err := fmt.Fprintln(out, "time_unit:", m.TimeUnit); err != nil {
			return err
		}
	}
	for _, snap := range m.Snapshots {
		if err := snapshotTemplate.Execute(out, snap); err != nil {
			return err
		}
	}
	return nil
}

type parser struct {
	sc *bufio.Scanner
	// The final output struct values are accumulated into.
	m *Massif
	// Set to true once we have reached the end of the file.
	atEOF bool
	// The line that is currently being read.
	line int
}

func (p *parser) abort(f string, args ...interface{}) {
	newArgs := append([]interface{}{p.line}, args...)
	panic(fmt.Errorf("[line %d] "+f, newArgs...))
}

type eofContext string

const (
	noAbortOnEOF eofContext = ""
)

func (p *parser) scan(c eofContext) {
	p.atEOF = !p.sc.Scan()
	if p.atEOF {
		err := p.sc.Err()
		if err != nil {
			panic(err)
		}
		if c != noAbortOnEOF {
			p.abort("unexpected end of file while parsing %s", c)
		}
	} else {
		p.line++
	}
}

func (p *parser) text() string {
	return p.sc.Text()
}

func (p *parser) tryParseHeaderField(field string, out *string) bool {
	line := p.text()
	if !strings.HasPrefix(line, field+": ") {
		return false
	}
	*out = strings.SplitN(line, " ", 2)[1]
	p.scan(noAbortOnEOF)
	return true
}

func (p *parser) parseHeader() {
	p.scan(noAbortOnEOF)
	p.tryParseHeaderField("desc", &p.m.Description)

	var command string
	if p.tryParseHeaderField("cmd", &command) {
		p.m.Binary = strings.Fields(command)[0]
		p.m.Args = strings.Fields(command)[1:]
	}

	p.tryParseHeaderField("time_unit", &p.m.TimeUnit)
}

func (p *parser) eatLine(c eofContext, l string) {
	if line := p.text(); !(line == l) {
		p.abort("got line %q, expected %q", line, l)
	}
	p.scan(c)
}

func (p *parser) parseSnapshotVar(name string) string {
	line := p.text()
	fields := strings.SplitN(line, "=", 2)
	if len(fields) < 2 {
		p.abort("got %q, expected variable \"%s=...\"", line, name)
	}
	parsedName, value := fields[0], fields[1]
	if parsedName != name {
		p.abort("got variable %q, but looking for variable %q", parsedName, name)
	}
	return value
}

func (p *parser) parseSnapshotVarInt64(name string) int64 {
	raw := p.parseSnapshotVar(name)
	val, err := strconv.ParseInt(raw, 10, 64)
	if err != nil {
		p.abort("snapshot variable %q value %q not an integer: %v", name, raw, err)
	}
	return val
}

func (p *parser) parseDetailedHeapTree() string {
	var tree strings.Builder
	var addNewline bool
	// Not using p.scan, because we want to catch EOF here.
	for p.sc.Scan() {
		// If we're about to start the next snapshot, then we're done parsing
		// the heap tree.
		if p.text() == snapshotSeparator {
			return tree.String()
		}
		if addNewline {
			tree.WriteByte('\n')
		}
		tree.WriteString(p.text())
		addNewline = true
	}
	// Need to update p.atEOF, so we can detect partially recognized input.
	p.atEOF = true
	return tree.String()
}

func (p *parser) parseSnapshot() Snapshot {
	var s Snapshot
	p.eatLine("snapshot", snapshotSeparator)

	s.Index = int(p.parseSnapshotVarInt64("snapshot"))
	p.scan("snapshot")

	p.eatLine("snapshot", snapshotSeparator)

	s.Time = p.parseSnapshotVar("time")
	p.scan("snapshot")
	s.MemoryHeap = unit.Datasize(p.parseSnapshotVarInt64("mem_heap_B")) * unit.Byte
	p.scan("snapshot")
	s.MemoryHeapExtra = unit.Datasize(p.parseSnapshotVarInt64("mem_heap_extra_B")) * unit.Byte
	p.scan("snapshot")
	s.MemoryStack = unit.Datasize(p.parseSnapshotVarInt64("mem_stacks_B")) * unit.Byte
	p.scan("snapshot")
	heapType := p.parseSnapshotVar("heap_tree")

	if heapType == "empty" {
		p.scan(noAbortOnEOF)
		return s
	}

	// Note, this assumes we did *not* call p.scan() after parsing "heap_tree"
	s.HeapTree = p.parseDetailedHeapTree()
	return s
}

func (p *parser) parse() (err error) {
	defer func() {
		e := recover()
		if e == nil {
			return
		}
		err = e.(error)
	}()
	p.parseHeader()
	for p.text() == snapshotSeparator {
		p.m.Snapshots = append(p.m.Snapshots, p.parseSnapshot())
	}
	if !p.atEOF {
		p.abort("trailing unparsable content starting on this line.")
	}
	return p.sc.Err()
}

// Parse parses the given reader, returning the parsed representation as a
// `Massif` structure, or an error if the input file could not be parsed.
func Parse(in io.Reader) (*Massif, error) {
	var out Massif
	p := parser{sc: bufio.NewScanner(in), m: &out}
	if err := p.parse(); err != nil {
		return nil, err
	}
	return &out, nil
}
